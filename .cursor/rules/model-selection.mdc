---
description: Smart model selection to optimize token usage and stay within Pro+ quota
alwaysApply: true
priority: 200
---

# Model Selection Strategy

## PRINCIPLE

**Use the right model for the task: Opus for critical thinking, Sonnet for execution**

```yaml
Goal: Stay within $70-100/month on Pro+ ($60/month)
Current burn rate: $370/month (need 73% reduction)
Target: Opus <10%, Sonnet >90%
```

---

## CRITICAL CONTEXT

```yaml
User's situation:
  - Plan: Pro+ ($60/month)
  - Previous: Ultra ($200/month, 20x limits)
  - Current usage: 75% Opus, 25% Sonnet
  - Burn rate: $370/month (6x over budget)
  - Challenge: Reduce to $70-100/month
  
Constraints:
  - Cannot sacrifice quality on critical tasks
  - Must maintain productivity
  - Need systematic approach
```

---

## MODEL SELECTION RULES

### Use Opus 4.6 (expensive: $15/1M input)

```yaml
ONLY for these tasks:
  1. Architecture decisions:
     - System design choices
     - Technology selection with trade-offs
     - Breaking changes planning
     - Performance optimization strategy
  
  2. Critical code review:
     - Security-sensitive code
     - Core business logic
     - Database schema changes
     - API contract changes
  
  3. Complex debugging:
     - Production issues
     - Data corruption
     - Race conditions
     - Memory leaks
  
  4. Specification review:
     - openspec/ documents validation
     - Architecture document review
     - Critical decision validation

Target: <10% of total tokens (6M tokens/month)
Budget: ~$10-15/month
```

### Use Sonnet 4.5 (default: $3/1M input)

```yaml
For EVERYTHING else:
  1. Code generation:
     - Forms, tests, queries
     - Boilerplate code
     - Configuration files
     - Scripts and automation
  
  2. Routine code review:
     - Style compliance
     - BSL standards
     - Non-critical modules
     - Refactoring suggestions
  
  3. Questions and exploration:
     - "How does X work?"
     - Code search and navigation
     - Documentation lookup
     - Learning and tutorials
  
  4. Agents (all types):
     - onec-code-reviewer: Sonnet (Opus only on explicit request)
     - onec-form-generator: Sonnet
     - onec-query-optimizer: Sonnet
     - onec-test-generator: Sonnet
     - All infrastructure agents: Sonnet
  
  5. Iterative work:
     - Bug fixes (non-critical)
     - Feature implementation
     - Testing and validation
     - Documentation updates

Target: >90% of total tokens (54M tokens/month)
Budget: ~$55-70/month
```

---

## DECISION FLOWCHART

```yaml
Before responding, ask:

1. Is this a critical decision?
   - Architecture choice? â†’ Opus
   - Technology selection? â†’ Opus
   - Security review? â†’ Opus
   - Everything else â†’ Continue to 2

2. Is this production-critical?
   - Production bug? â†’ Opus
   - Data integrity? â†’ Opus
   - Core business logic? â†’ Opus
   - Everything else â†’ Continue to 3

3. Does it require deep reasoning?
   - Multiple trade-offs? â†’ Opus
   - Complex debugging? â†’ Opus
   - Novel problem? â†’ Opus
   - Everything else â†’ Sonnet

4. Default â†’ Sonnet
```

---

## AGENT CONFIGURATION

### Default Agent Model

```yaml
All agents use Sonnet by default:
  - onec-code-reviewer: Sonnet (fast: true)
  - onec-form-generator: Sonnet (fast: true)
  - onec-query-optimizer: Sonnet (fast: true)
  - onec-test-generator: Sonnet (fast: true)
  - server-admin: Sonnet (fast: true)
  - onec-admin: Sonnet (fast: true)
  - backup-admin: Sonnet (fast: true)
  - network-admin: Sonnet (fast: true)
  - media-admin: Sonnet (fast: true)
  - mcp-deploy: Sonnet (fast: true)
  - dev-optimizer: Sonnet (fast: true)
  - explore: Sonnet (fast: true)

Exception: User explicitly requests Opus
  Example: "review this code with Opus"
  Action: Launch agent with model: "opus" (not "fast")
```

### When to Override to Opus

```yaml
User explicitly requests:
  - "review with Opus"
  - "use Opus for this"
  - "critical review"
  - "deep analysis"
  - "architecture review"

Agent detects critical issue:
  - Security vulnerability
  - Data corruption risk
  - Breaking change detected
  - Production impact
  
Action:
  1. Notify user: "Detected critical issue, recommend Opus review"
  2. Ask permission: "Switch to Opus? (will use more quota)"
  3. If approved: Use Opus
  4. If declined: Continue with Sonnet, flag issue
```

---

## CONTEXT OPTIMIZATION

### RLM-First Approach

```yaml
ALWAYS use RLM for context:
  1. Start of chat:
     rlm_enterprise_context(query="<task description>")
  
  2. Before loading files:
     - Check RLM first: Is this already known?
     - Load only if needed: Avoid redundant reads
  
  3. After decisions:
     - Save to RLM: rlm_record_causal_decision
     - Sync state: rlm_sync_state

Token savings: 99.96% on context (50k â†’ 440 tokens)
Budget impact: ~$10-20/month saved
```

### New Chat Strategy

```yaml
Start new chat when:
  - Tokens > 500k: Immediate
  - Task completed: Major milestone
  - Context switch: Different domain
  - Daily: End of work day

Before new chat:
  1. Save key decisions to RLM
  2. Sync state: rlm_sync_state
  3. Start fresh: Load via rlm_enterprise_context

Token savings: 90% on large contexts
Budget impact: ~$10-15/month saved
```

### Agent Isolation

```yaml
Use agents for parallel tasks:
  - Each agent: Own context (isolated)
  - Main chat: Only results (summary)
  - Token savings: 80-90%

Example:
  Task: "Check all MCP servers"
  
  Wrong (main chat):
    - Load all MCP configs: 50k tokens
    - Check each server: 20k tokens Ã— 5 = 100k
    - Total: 150k tokens in main chat
  
  Right (agents):
    - Launch 5 agents in parallel: 20k tokens each (isolated)
    - Main chat: Only summaries: 5k tokens
    - Total in main chat: 5k tokens (97% savings)

Budget impact: ~$15-25/month saved
```

---

## DAILY BUDGET TRACKING

### Target Budget

```yaml
Monthly budget: $70-100
Daily budget: $2.30-3.30
Hourly budget: $0.30-0.40 (8h work day)

Current burn rate: $12/day (need 73% reduction)
Target burn rate: $3/day
```

### Monitoring Commands

```yaml
Check usage:
  - "ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²": Current session + daily
  - "Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð¿Ð¾ API": Detailed breakdown
  - "Ð¿Ð¾ÐºÐ°Ð¶Ð¸ Ð±ÑŽÐ´Ð¶ÐµÑ‚": Daily budget status

Automatic alerts:
  - Daily >$5: Warning "Exceeded daily budget"
  - Daily >$10: Critical "Emergency optimization needed"
  - Weekly >$25: Alert "On track to exceed monthly"
```

### Daily Checklist

```yaml
Morning (start of day):
  - [ ] Check yesterday's usage: "ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²"
  - [ ] Review budget: On track?
  - [ ] Plan critical tasks: Which need Opus?
  - [ ] Set model preference: Sonnet by default

During work:
  - [ ] Before Opus: Ask "Is this critical?"
  - [ ] Use RLM: For all context
  - [ ] Use agents: For parallel tasks
  - [ ] New chat: At 500k tokens

Evening (end of day):
  - [ ] Check usage: "ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²"
  - [ ] Save to RLM: Key decisions
  - [ ] New chat: For tomorrow
  - [ ] Review: What can optimize tomorrow?
```

---

## OPTIMIZATION TECHNIQUES

### Technique 1: Batch Operations

```yaml
Instead of:
  - 10 separate questions: 10 Ã— 5k = 50k tokens
  
Do:
  - 1 batched question: 1 Ã— 10k = 10k tokens
  
Example:
  Wrong: "Check server 1", "Check server 2", ...
  Right: "Check all servers: 1, 2, 3, 4, 5"

Savings: 80%
```

### Technique 2: Incremental Context

```yaml
Instead of:
  - Loading full file (10k lines): 50k tokens
  
Do:
  - Load only relevant section: 5k tokens
  - Expand if needed: +5k tokens
  
Example:
  Wrong: Read entire module
  Right: Read function signature, expand if needed

Savings: 50-90%
```

### Technique 3: Skill Creation

```yaml
For repetitive tasks:
  - Create skill: One-time cost (5k tokens)
  - Use skill: Minimal cost (500 tokens)
  - After 10 uses: 90% savings

Example:
  Task: "Find 1C function X" (repeated 20 times/month)
  
  Without skill: 20 Ã— 5k = 100k tokens
  With skill: 5k (creation) + 20 Ã— 0.5k = 15k tokens
  
Savings: 85%
```

### Technique 4: Smart Caching

```yaml
Cache in RLM:
  - Infrastructure facts: Servers, ports, configs
  - Code patterns: Common solutions
  - Decision history: Past choices
  - Project structure: File locations

Reuse:
  - Load from RLM: 440 tokens
  - Instead of re-reading: 10k-50k tokens

Savings: 95-99%
```

---

## EMERGENCY MODE

### Trigger Conditions

```yaml
Activate when:
  - Daily usage >$10: Critical
  - Weekly usage >$50: Warning
  - Monthly projection >$150: Alert
```

### Emergency Actions

```yaml
Immediate:
  1. Opus disabled: Only Sonnet (except explicit request)
  2. RLM-only context: No file reads without RLM check
  3. Agent isolation: All tasks via agents
  4. New chat: Every 100k tokens (aggressive)
  5. Batch everything: No single operations

Notification:
  "ðŸš¨ Emergency mode activated. Daily budget exceeded.
  
  Actions taken:
  - Opus disabled (Sonnet only)
  - RLM-only context
  - Aggressive optimization
  
  Current: $X/day (target: $3/day)
  Projected monthly: $Y (target: $100)
  
  Continue in emergency mode? [Yes] [Disable]"

Duration:
  - Until daily average <$5 for 3 days
  - Or user manually disables
```

---

## WEEKLY REVIEW

### Every Sunday

```yaml
Generate report:
  1. Usage breakdown:
     - Opus: X% (target: <10%)
     - Sonnet: Y% (target: >90%)
     - Total: $Z (target: <$25/week)
  
  2. Top consumers:
     - Task type 1: $A
     - Task type 2: $B
     - Task type 3: $C
  
  3. Optimization opportunities:
     - Skill creation: Save $X
     - More RLM: Save $Y
     - More agents: Save $Z
  
  4. Forecast:
     - Projected monthly: $M
     - Over/under budget: Â±$N
     - Recommendations: [List]

Store in:
  - RLM: rlm_add_hierarchical_fact
  - File: .cursor/dev-optimizer-reports/weekly/YYYY-MM-DD.md
```

---

## SUCCESS METRICS

### Target Metrics (by end of month)

```yaml
Model distribution:
  - Opus: <10% tokens (currently 75%)
  - Sonnet: >90% tokens (currently 25%)
  - Reduction: 73% in Opus usage

Cost:
  - Monthly: $70-100 (currently $370)
  - Daily: $2.30-3.30 (currently $12)
  - Reduction: 73-81%

Quality:
  - Critical tasks: Still use Opus (no compromise)
  - Routine tasks: Sonnet (acceptable quality)
  - Productivity: Maintained (via optimization)

Efficiency:
  - RLM usage: >80% of context loads
  - Agent isolation: >50% of tasks
  - New chats: <500k tokens average
```

### Progress Tracking

```yaml
Week 1 (current):
  - Baseline: $370/month burn rate
  - Target: Reduce to $200/month (50% reduction)
  - Focus: Model selection discipline

Week 2:
  - Target: Reduce to $150/month (60% reduction)
  - Focus: RLM integration everywhere

Week 3:
  - Target: Reduce to $120/month (68% reduction)
  - Focus: Agent isolation, skill creation

Week 4:
  - Target: Reach $100/month (73% reduction)
  - Focus: Fine-tuning, emergency mode if needed
```

---

## EXAMPLES

### Example 1: Code Review (Routine)

```yaml
Task: "Review CommonModule for style compliance"

Decision:
  - Critical? No (style, not security)
  - Production? No (routine review)
  - Deep reasoning? No (BSL standards)
  
Model: Sonnet âœ…

Process:
  1. Launch onec-code-reviewer agent (Sonnet, fast: true)
  2. Agent uses BSL LSP Bridge (diagnostics)
  3. Agent checks BSL standards
  4. Returns report with issues
  
Cost: ~$0.50 (vs $2.50 with Opus)
Savings: 80%
```

### Example 2: Architecture Decision (Critical)

```yaml
Task: "Choose database for new feature: PostgreSQL vs MongoDB"

Decision:
  - Critical? Yes (architecture choice)
  - Production? Yes (affects system)
  - Deep reasoning? Yes (trade-offs)
  
Model: Opus âœ…

Process:
  1. Use Opus for analysis
  2. Consider: Performance, scalability, team expertise
  3. Document trade-offs
  4. Save decision to RLM: rlm_record_causal_decision
  
Cost: ~$3 (justified for critical decision)
Quality: High (worth the cost)
```

### Example 3: Form Generation (Routine)

```yaml
Task: "Generate managed form for Catalog.Clients"

Decision:
  - Critical? No (code generation)
  - Production? No (will be reviewed)
  - Deep reasoning? No (template-based)
  
Model: Sonnet âœ…

Process:
  1. Launch onec-form-generator agent (Sonnet, fast: true)
  2. Agent uses form schema (XSD/JSON)
  3. Agent generates form XML
  4. Validates with BSL LSP
  
Cost: ~$0.30 (vs $1.50 with Opus)
Savings: 80%
```

### Example 4: Production Bug (Critical)

```yaml
Task: "Data corruption in client orders, urgent fix needed"

Decision:
  - Critical? Yes (data integrity)
  - Production? Yes (live issue)
  - Deep reasoning? Yes (complex debugging)
  
Model: Opus âœ…

Process:
  1. Use Opus for debugging
  2. Analyze: Data flow, race conditions
  3. Identify: Root cause
  4. Propose: Fix with validation
  5. Save to RLM: For future reference
  
Cost: ~$5 (justified for production issue)
Quality: Critical (no compromise)
```

---

## ANTI-PATTERNS

### âŒ Don't Do This

```yaml
1. Using Opus for simple questions:
   Wrong: "What does this function do?" (Opus)
   Right: "What does this function do?" (Sonnet)
   
2. Loading full files without RLM:
   Wrong: Read entire module (50k tokens)
   Right: Check RLM first, load only if needed
   
3. Sequential agent calls:
   Wrong: Launch 5 agents one by one
   Right: Launch 5 agents in parallel
   
4. Long chats without breaks:
   Wrong: Continue chat to 1M tokens
   Right: New chat at 500k, save to RLM
   
5. Opus for code generation:
   Wrong: "Generate form with Opus"
   Right: "Generate form with Sonnet"
```

---

## INTEGRATION WITH OTHER RULES

```yaml
Works with:
  - dev-optimizer-autorun.mdc: Automatic monitoring
  - context-management.mdc: New chat strategy
  - bsl-lsp-integration.mdc: BSL LSP for validation
  - rlm-toolkit-autoload.mdc: RLM for context
  - sdd-workflow.mdc: Opus for spec review

Priority:
  - This rule: 200 (high priority)
  - Ensures: Model selection before execution
```

---

## CRITICAL RULES

1. **Sonnet by default** - Opus only for critical tasks
2. **Ask before Opus** - "Is this critical enough?"
3. **RLM for context** - Always check RLM first
4. **Agents for isolation** - Parallel tasks via agents
5. **New chat at 500k** - Aggressive context management
6. **Daily budget** - Track and adjust
7. **Weekly review** - Measure progress
8. **Emergency mode** - Activate if needed
9. **No compromise on critical** - Quality over cost for important tasks
10. **Measure everything** - Track all metrics in RLM

---

## QUICK REFERENCE

### Model Selection Cheat Sheet

```yaml
Opus ($15/1M):
  âœ… Architecture decisions
  âœ… Critical code review
  âœ… Production bugs
  âœ… Complex debugging
  âœ… Spec validation
  âŒ Everything else

Sonnet ($3/1M):
  âœ… Code generation
  âœ… Routine review
  âœ… Questions
  âœ… All agents
  âœ… Iterative work
  âœ… 90% of tasks
```

### Daily Budget

```yaml
Target: $2.30-3.30/day
Current: $12/day
Reduction needed: 73%

Breakdown:
  - Opus: <$0.50/day (critical only)
  - Sonnet: <$2.50/day (everything else)
  - Buffer: $0.30/day (unexpected)
```

### Commands

```yaml
"ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‚Ð¾ÐºÐµÐ½Ð¾Ð²": Check current usage
"Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð¿Ð¾ API": Detailed breakdown
"Ð¿Ð¾ÐºÐ°Ð¶Ð¸ Ð±ÑŽÐ´Ð¶ÐµÑ‚": Daily budget status
"emergency mode": Activate emergency optimization
```

---

**Last updated:** 2026-02-08
**Version:** 1.0
**Challenge:** Reduce burn rate from $370 to $70-100/month (73% reduction)
**Status:** Active monitoring
