---
description: "MCP tools usage patterns, decision trees, and when to use which tool"
alwaysApply: true
priority: 150
---

# MCP Tools Usage Guide

## PRINCIPLE

**Choose the right tool based on task context, not tool name similarity**

```yaml
Strategy:
 1. Identify task type (search, validate, analyze, etc)
 2. Identify domain (1C docs, project code, metadata, etc)
 3. Use decision tree to select tool
 4. Call tool with correct parameters
 5. If unclear, load skill for detailed guidance

Token savings:
 - Clear decision trees: -30% exploratory calls
 - Parameter documentation: -20% trial-and-error
 - Context-aware selection: +50% first-try success
```

---

## TOOL CATEGORIES

### 1. Documentation & Reference Tools
**Purpose:** Find information about 1C platform, БСП, templates

**Tools:**
- `search_1c_docs`: Platform documentation (methods, syntax)
- `search_bsp_functions`: БСП (SSL) library functions
- `search_1c_templates`: Code templates and patterns

### 2. Code Validation Tools
**Purpose:** Check syntax and logic errors

**Tools:**
- `check_bsl_syntax`: BSL syntax validation
- `check_1c_logic`: Business logic validation via 1С:Напарник

### 3. Forms Tools
**Purpose:** Work with 1C managed forms

**Tools:**
- `get_form_xsd_schema`: XSD schema for forms
- `get_form_json_schema`: JSON schema for forms
- `get_form_instructions`: Integration instructions

### 4. Project-Specific Tools
**Purpose:** Search code, metadata, documentation in specific projects

**Projects:** KAF, MCParqa24, MCParqa24MCP, Rarus

**Tool patterns:**
- `search_{project}_metadata`: Configuration objects
- `search_{project}_code`: BSL code
- `search_{project}_help`: Documentation
- `search_{project}_graph_metadata`: Neo4j graph search
- `search_{project}_business`: Semantic business docs search
- `execute_{project}_cypher`: Direct Cypher queries
- `answer_{project}_question`: Natural language Q&A

### 5. RLM Tools
**Purpose:** Persistent memory and context management

**Tools:**
- `get_rlm_context`: Load enterprise context (start of chat)
- `search_rlm_facts`: Find specific facts
- `add_rlm_fact`: Save new fact
- `record_rlm_decision`: Save architectural decision
- `start_rlm_session`: Initialize session
- `sync_rlm_state`: Persist to disk
- `route_rlm_context`: Semantic routing
- `discover_rlm_project`: Cold start discovery

### 6. LSP Tools
**Purpose:** Code analysis, navigation, refactoring via Language Server

**Tools:**
- `get_diagnostics`: Errors and warnings
- `get_definition`: Symbol definition location
- `get_call_graph`: Complete call graph
- `get_call_hierarchy`: Callers and callees
- `get_symbol_info`: Hover information
- `get_code_actions`: Quick fixes and refactorings
- `rename_symbol`: Safe cross-file rename
- `analyze_project`: Multi-purpose analysis
- `explore_symbols`: Intelligent symbol search

---

## DECISION TREES

### Tree 1: Documentation Search

```yaml
User asks about 1C method/function:
 → "Как использовать СтрРазделить?"
 → "What does ПолучитьДанные do?"
 
Decision:
 1. Is it platform method? → search_1c_docs
 2. Is it БСП function? → search_bsp_functions
 3. Need code example? → search_1c_templates

Examples:
 - "Как разделить строку?" → search_1c_docs(query="СтрРазделить")
 - "Функции работы с файлами БСП" → search_bsp_functions(query="файлы")
 - "Шаблон обработки" → search_1c_templates(query="обработка")
```

### Tree 2: Code Validation

```yaml
User wants to validate code:
 → "Проверь код на ошибки"
 → "Есть ли синтаксические ошибки?"
 
Decision:
 1. Syntax errors? → check_bsl_syntax
 2. Logic errors? → check_1c_logic
 3. Both? → check_bsl_syntax first, then check_1c_logic

Examples:
 - "Проверь синтаксис модуля" → check_bsl_syntax(code="...")
 - "Правильная ли логика?" → check_1c_logic(code="...")
 - "Полная проверка" → check_bsl_syntax + check_1c_logic
```

### Tree 3: Project Code Search

```yaml
User asks about project code:
 → "Где реализована функция X?"
 → "Какие поля у справочника Y?"
 → "Для чего нужен объект Z?"

Decision:
 1. Which project? (KAF, MCParqa24, Rarus)
 2. What to find?
 - Metadata (objects, fields) → search_{project}_metadata
 - Code (functions, procedures) → search_{project}_code
 - Documentation (purpose, usage) → search_{project}_help
 - Graph relationships → search_{project}_graph_metadata
 - Business context → search_{project}_business

Examples:
 - "Поля справочника Контрагенты в KAF" 
 → search_kaf_metadata(query="Справочники.Контрагенты.Реквизиты")
 
 - "Где функция ПолучитьДанные в MCParqa24"
 → search_mcparqa24_code(query="ПолучитьДанные")
 
 - "Для чего документ ЗаказКлиента в Rarus"
 → search_rarus_help(query="ЗаказКлиента")
```

### Tree 4: RLM Context Management

```yaml
Situation determines tool:

Start of chat:
 → get_rlm_context(query="<task description>")
 → Loads all relevant project context

Looking for specific fact:
 → search_rlm_facts(query="<keyword>")
 → Targeted search

Save important decision:
 → record_rlm_decision(
 decision="...",
 reasons=["..."],
 consequences=["..."]
 )

Save general fact:
 → add_rlm_fact(
 content="...",
 level=0,
 domain="..."
 )

End of work session:
 → sync_rlm_state()
 → Persist to disk

Examples:
 - Start: get_rlm_context(query="MCP servers and infrastructure")
 - Search: search_rlm_facts(query="BSL LSP Bridge port")
 - Save: record_rlm_decision(decision="Use PostgreSQL for 1C")
 - Persist: sync_rlm_state()
```

### Tree 5: LSP Code Analysis

```yaml
User needs code analysis:
 → "Есть ли ошибки в файле?"
 → "Где определена функция?"
 → "Кто вызывает эту функцию?"

Decision:
 1. What information needed?
 
 Errors/warnings:
 → get_diagnostics(uri="file://...")
 
 Definition location:
 → get_definition(uri="file://...", line=X, character=Y)
 
 Call relationships:
 → get_call_graph(uri="file://...", line=X, character=Y)
 → get_call_hierarchy(uri="file://...", line=X, character=Y)
 
 Symbol information:
 → get_symbol_info(uri="file://...", line=X, character=Y)
 
 Quick fixes:
 → get_code_actions(uri="file://...", line=X, character=Y)
 
 Rename:
 → prepare_rename(uri="file://...", line=X, character=Y)
 → rename_symbol(uri="file://...", line=X, character=Y, new_name="...")

Examples:
 - "Ошибки в модуле" → get_diagnostics(uri="file://path/to/module.bsl")
 - "Где определена функция" → get_definition(uri="...", line=10, character=5)
 - "Кто вызывает" → get_call_graph(uri="...", line=10, character=5)
```

---

## USAGE PATTERNS

### Pattern 1: Start of Chat (Load Context)

```yaml
ALWAYS at start of chat:
 1. Call get_rlm_context(query="<task description>")
 2. Get project context (infrastructure, decisions, facts)
 3. Proceed with task

Example:
 User: "Проверь статус MCP серверов"
 
 Step 1: get_rlm_context(query="MCP servers infrastructure")
 Step 2: Use context to understand which servers exist
 Step 3: Check each server
```

### Pattern 2: Documentation Lookup

```yaml
User asks "how to do X":
 1. Identify domain (platform, БСП, templates)
 2. Search appropriate documentation
 3. If not found, try alternative source
 4. Return answer with examples

Example:
 User: "Как работать с файлами?"
 
 Step 1: search_1c_docs(query="работа с файлами")
 Step 2: If not enough, search_bsp_functions(query="файлы")
 Step 3: If need example, search_1c_templates(query="работа с файлами")
```

### Pattern 3: Code Search in Project

```yaml
User asks about project code:
 1. Identify project (KAF, MCParqa24, Rarus)
 2. Identify what to find (metadata, code, docs)
 3. Use appropriate search tool
 4. If not found, try alternative (code → metadata → help)

Example:
 User: "Где функция ПолучитьКлиента в KAF?"
 
 Step 1: search_kaf_code(query="ПолучитьКлиента")
 Step 2: If not found, search_kaf_metadata(query="ПолучитьКлиента")
 Step 3: If still not found, search_kaf_help(query="получение клиента")
```

### Pattern 4: Code Validation Workflow

```yaml
Before committing code:
 1. Check syntax: check_bsl_syntax
 2. If syntax OK, check logic: check_1c_logic
 3. If errors, fix and re-check
 4. If OK, proceed with commit

Example:
 User: "Проверь код перед коммитом"
 
 Step 1: check_bsl_syntax(code="...")
 Step 2: If errors, report and stop
 Step 3: If OK, check_1c_logic(code="...")
 Step 4: If errors, report and stop
 Step 5: If OK, approve commit
```

### Pattern 5: Deep Code Analysis

```yaml
User needs comprehensive analysis:
 1. Get diagnostics: get_diagnostics
 2. Analyze call graph: get_call_graph
 3. Check symbol usage: explore_symbols
 4. Propose improvements: get_code_actions

Example:
 User: "Проанализируй модуль полностью"
 
 Step 1: get_diagnostics(uri="...")
 Step 2: For each function, get_call_graph(...)
 Step 3: explore_symbols(query="module symbols")
 Step 4: get_code_actions(uri="...") for improvements
```

---

## TOOL NAME MAPPING

**IMPORTANT:** MCP servers use original names. This mapping is for AI reasoning clarity.

```yaml
Conceptual Name → Actual MCP Tool Name

1C Documentation:
 search_1c_docs → user-1c-help-docsearch
 search_bsp_functions → user-1c-ssl-ssl_search
 search_1c_templates → user-1c-templates-templatesearch

Code Validation:
 check_bsl_syntax → user-1c-syntax-checker-syntaxcheck
 check_1c_logic → user-1c-code-checker-check_1c_code

Forms:
 get_form_xsd_schema → user-1c-forms-get_xsd_schema
 get_form_json_schema → user-1c-forms-get_json_schema
 get_form_instructions → user-1c-forms-get_instructions

(Full mapping in docs/mcp-tool-registry.md)
```

---

## TOOL REFERENCE

### 1C Documentation Tools

#### search_1c_docs
```yaml
Purpose: Search 1C platform documentation
When: User asks about platform method/function
Actual tool: user-1c-help-docsearch
Parameters:
 - query (string, required): Method name or description in Russian
Returns: Top search results with documentation
Example: user-1c-help-docsearch(query="СтрРазделить")
Skill: .cursor/skills/1c-help-mcp/SKILL.md
```

#### search_bsp_functions
```yaml
Purpose: Search БСП (SSL) library functions
When: User asks about standard subsystems
Parameters:
 - query (string, required): Function name or description
Returns: БСП functions with usage examples
Example: search_bsp_functions(query="работа с файлами")
Skill: .cursor/skills/1c-ssl-mcp/SKILL.md
```

#### search_1c_templates
```yaml
Purpose: Search 1C code templates
When: User needs code example or boilerplate
Parameters:
 - query (string, required): Template description
Returns: Code templates with examples
Example: search_1c_templates(query="обработка с формой")
Skill: .cursor/skills/1c-templates-mcp/SKILL.md
```

### Code Validation Tools

#### check_bsl_syntax
```yaml
Purpose: Check BSL syntax errors
When: Before commit, after code generation
Parameters:
 - code (string, required): BSL code to check
Returns: Syntax errors with line numbers
Example: check_bsl_syntax(code="Процедура Test() КонецПроцедуры")
Skill: .cursor/skills/1c-syntax-checker-mcp/SKILL.md
```

#### check_1c_logic
```yaml
Purpose: Check 1C business logic via 1С:Напарник
When: Deep code analysis, logic validation
Parameters:
 - code (string, required): BSL code to check
 - check_type (string, optional): "syntax", "logic", "performance"
Returns: Logic errors and recommendations
Example: check_1c_logic(code="...", check_type="logic")
Skill: .cursor/skills/1c-code-checker-mcp/SKILL.md
```

### Forms Tools

#### get_form_xsd_schema
```yaml
Purpose: Get XSD schema for 1C forms
When: Generating forms, need schema reference
Parameters: None
Returns: Complete XSD schema definition
Example: get_form_xsd_schema()
Skill: .cursor/skills/1c-forms-mcp/SKILL.md
```

#### get_form_json_schema
```yaml
Purpose: Get JSON schema for 1C forms
When: Generating forms, prefer JSON format
Parameters: None
Returns: JSON schema with metadata
Example: get_form_json_schema()
Skill: .cursor/skills/1c-forms-mcp/SKILL.md
```

#### get_form_instructions
```yaml
Purpose: Get form integration instructions
When: Need to integrate generated form into metadata
Parameters: None
Returns: Step-by-step integration guide
Example: get_form_instructions()
Skill: .cursor/skills/1c-forms-mcp/SKILL.md
```

---

## CRITICAL RULES

1. **Start with RLM** — Always call `get_rlm_context` at start of chat
2. **Use decision trees** — Don't guess, follow the tree
3. **Load skills when needed** — Reference skill files for detailed guidance
4. **Validate before commit** — Always check syntax and logic
5. **Search in order** — Try specific → general → alternative
6. **Save decisions** — Use `record_rlm_decision` for important choices
7. **Sync at end** — Call `sync_rlm_state` after major work

---

## INTEGRATION WITH OTHER RULES

This rule works with:
- `rlm-toolkit-autoload.mdc` — RLM context management
- `bsl-lsp-integration.mdc` — LSP tool usage
- `context-management.mdc` — Agent usage patterns
- `model-selection.mdc` — When to use Opus vs Sonnet

---

## EXAMPLES

### Example 1: Documentation Lookup

```yaml
User: "Как использовать СтрРазделить?"

Decision tree:
 - Platform method? Yes
 - Tool: search_1c_docs

Action:
 search_1c_docs(query="СтрРазделить")

Result:
 - Function signature
 - Parameters
 - Return value
 - Examples
```

### Example 2: Project Code Search

```yaml
User: "Где функция ПолучитьКлиента в KAF?"

Decision tree:
 - Project: KAF
 - Find: Code
 - Tool: search_kaf_code

Action:
 search_kaf_code(query="ПолучитьКлиента", limit=5)

Result:
 - File locations
 - Function signatures
 - Usage examples
```

### Example 3: Code Validation

```yaml
User: "Проверь этот код"

Decision tree:
 - Syntax check? Yes
 - Logic check? Yes
 - Tools: check_bsl_syntax → check_1c_logic

Actions:
 1. check_bsl_syntax(code="...")
 2. If OK, check_1c_logic(code="...")

Result:
 - Syntax: OK
 - Logic: 2 warnings (list)
 - Recommendations
```

---

**Last updated:** 2026-02-08
**Version:** 1.0
**Status:** Initial structure (pilot with 1c-help-mcp in progress)
