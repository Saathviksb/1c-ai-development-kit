# 1C Coding Standards

Стандарты написания кода на платформе 1С:Предприятие (BSL).

**Приоритет**: 150 (высокий)  
**Применяется**: Всегда при работе с кодом 1С

---

## ОБЩИЕ ПРИНЦИПЫ

### Комментарии

```yaml
Правило: Избегай комментариев, которые повторяют очевидное

Комментарии допускаются только когда добавляют ценность:
  - Мотивация решения
  - Нетривиальный алгоритм
  - Ограничения и граничные случаи
  - Контракты (параметры, возвращаемое значение)
  - Технический долг (TODO, FIXME)

Плохо:
  // Получаем клиента
  Клиент = ПолучитьКлиента();

Хорошо:
  // Используем кеш, т.к. данные клиента не меняются в рамках сессии
  Клиент = ПолучитьКлиентаИзКеша();
```

### Структура модулей

```yaml
Порядок областей в общем модуле:

1. #Область ПрограммныйИнтерфейс
   - Экспортные процедуры и функции
   - Доступны всем
   - Документированы (JSDoc-style)

2. #Область СлужебныйПрограммныйИнтерфейс
   - Экспортные процедуры и функции
   - Доступны только внутри подсистемы
   - Документированы

3. #Область СлужебныеПроцедурыИФункции
   - Неэкспортные процедуры и функции
   - Доступны только внутри модуля
   - Краткие комментарии (опционально)

Пример:
  #Область ПрограммныйИнтерфейс
  
  // Получает данные клиента
  //
  // Параметры:
  //   Клиент - СправочникСсылка.Клиенты - ссылка на клиента
  //
  // Возвращаемое значение:
  //   Структура - данные клиента с полями:
  //     * Наименование - Строка
  //     * ИНН - Строка
  //
  Функция ПолучитьДанныеКлиента(Клиент) Экспорт
      // ...
  КонецФункции
  
  #КонецОбласти
  
  #Область СлужебныеПроцедурыИФункции
  
  Функция ПолучитьДанныеКлиентаВнутренний(Клиент)
      // ...
  КонецФункции
  
  #КонецОбласти
```

### Переиспользование кода

```yaml
Правило: Перед написанием кода проверяй существующие методы

Где искать:
  1. Общие модули (ОбщегоНазначения, ОбщегоНазначенияКлиент)
  2. Модули менеджеров объектов
  3. БСП (Библиотека стандартных подсистем)
  4. MCP серверы (метаданные, код, справка)

Инструменты:
  - user-kaf-codemetadata-codesearch: Поиск по коду
  - user-kaf-graph-search_metadata: Поиск по метаданным
  - user-1c-help-docsearch: Справка по платформе
  - user-1c-ssl-ssl_search: Поиск в БСП
```

---

## ИМЕНОВАНИЕ

### Переменные

```yaml
Правило: Не используй венгерскую нотацию

Плохо:
  МассивКонтрагентов
  СтрокаИНН
  ЧислоКоличество

Хорошо:
  Контрагенты
  ИНН
  Количество

Исключение: Типы коллекций допустимы, если улучшают читаемость
  ТаблицаКлиентов  // ТаблицаЗначений
  СписокДокументов // СписокЗначений
```

### Глобальный контекст

```yaml
Правило: Не используй в именах переменных имена из глобального контекста 1С

Запрещено использовать:
  - Документы
  - Справочники
  - Регистры (РегистрыСведений, РегистрыНакопления, РегистрыБухгалтерии)
  - Метаданные
  - Константы
  - Пользователи
  - ПараметрыСеанса
  - РольДоступна
  - И другие глобальные объекты

Плохо:
  Документы = Новый Массив;
  Справочники = ПолучитьСправочники();

Хорошо:
  СписокДокументов = Новый Массив;
  ДанныеСправочников = ПолучитьСправочники();

Проверка: Используй MCP-справку для проверки коллизий
  user-1c-help-docsearch("имя переменной")
```

### Процедуры и функции

```yaml
Правило: Используй глаголы для процедур, вопросительную форму для предикатов

Процедуры (действие):
  ЗаполнитьТаблицу()
  ОбновитьДанные()
  СоздатьДокумент()
  УдалитьЗапись()

Функции-предикаты (проверка):
  ЭтоНовый()
  ЕстьОшибки()
  МожноИзменить()
  ДоступноПользователю()

Функции (получение):
  ПолучитьДанные()
  НайтиКлиента()
  ВычислитьСумму()
  СформироватьОтчет()
```

---

## ЗАПРОСЫ

### Форматирование

```yaml
Правило: Текст запроса без отступа на новой строке после =

Правильно:
  Запрос.Текст = 
  "ВЫБРАТЬ
  |    Таблица.Поле КАК Поле,
  |    Таблица.Поле2 КАК Поле2
  |ИЗ
  |    Справочник.Таблица КАК Таблица
  |ГДЕ
  |    Таблица.Поле = &Параметр";

Неправильно:
  Запрос.Текст = "ВЫБРАТЬ Таблица.Поле ИЗ Справочник.Таблица";
  
  Запрос.Текст = 
      "ВЫБРАТЬ
      |    Таблица.Поле
      |ИЗ
      |    Справочник.Таблица";  // Отступ после =
```

### Промежуточная переменная

```yaml
Правило: Для результата запроса используй промежуточную переменную

Плохо:
  Выборка = Запрос.Выполнить().Выбрать();
  Таблица = Запрос.Выполнить().Выгрузить();

Хорошо:
  РезультатЗапроса = Запрос.Выполнить();
  Выборка = РезультатЗапроса.Выбрать();
  
  РезультатЗапроса = Запрос.Выполнить();
  Таблица = РезультатЗапроса.Выгрузить();

Причина: Улучшает читаемость и отладку
```

### Псевдонимы

```yaml
Правило: Всегда давай псевдонимы полям через КАК

Плохо:
  ВЫБРАТЬ
      Контрагенты.ИНН,
      Контрагенты.Наименование
  ИЗ
      Справочник.Контрагенты

Хорошо:
  ВЫБРАТЬ
      Контрагенты.ИНН КАК ИНН,
      Контрагенты.Наименование КАК Наименование
  ИЗ
      Справочник.Контрагенты КАК Контрагенты

Причина: Явные имена полей в результате
```

### Проверка метаданных

```yaml
Правило: Перед написанием запроса проверяй метаданные

Проверяй:
  - Существование объекта метаданных
  - Имена реквизитов (точное написание)
  - Типы реквизитов
  - Индексы (для производительности)

Инструменты:
  user-kaf-codemetadata-metadatasearch("Справочники.Клиенты.Реквизиты")
  user-kaf-graph-search_metadata("Справочник Клиенты")
  user-mcparqa24-codemetadata-metadatasearch("Клиенты")
```

---

## ПРОИЗВОДИТЕЛЬНОСТЬ

### Запросы в цикле

```yaml
Правило: Не используй запросы внутри цикла

Плохо:
  Выборка = Запрос.Выполнить().Выбрать();
  Пока Выборка.Следующий() Цикл
      ДанныеКлиента = ПолучитьДанныеКлиента(Выборка.Клиент); // Запрос!
      // ...
  КонецЦикла;

Хорошо (вариант 1 - JOIN):
  Запрос.Текст = 
  "ВЫБРАТЬ
  |    Клиенты.Ссылка КАК Клиент,
  |    Данные.Поле1 КАК Поле1,
  |    Данные.Поле2 КАК Поле2
  |ИЗ
  |    Справочник.Клиенты КАК Клиенты
  |    ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ДанныеКлиентов КАК Данные
  |    ПО Клиенты.Ссылка = Данные.Клиент";

Хорошо (вариант 2 - временная таблица):
  Запрос.Текст = 
  "ВЫБРАТЬ
  |    Клиенты.Ссылка КАК Клиент
  |ПОМЕСТИТЬ ВТ_Клиенты
  |ИЗ
  |    Справочник.Клиенты КАК Клиенты;
  |
  |ВЫБРАТЬ
  |    ВТ_Клиенты.Клиент,
  |    Данные.Поле1,
  |    Данные.Поле2
  |ИЗ
  |    ВТ_Клиенты КАК ВТ_Клиенты
  |    ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ДанныеКлиентов КАК Данные
  |    ПО ВТ_Клиенты.Клиент = Данные.Клиент";

Причина: Запросы в цикле = N+1 проблема (10x медленнее)
```

### Реквизиты из ссылки

```yaml
Правило: Не получай реквизиты из ссылки через точку

Плохо:
  ИНН = Клиент.ИНН;  // Загружает весь объект!
  Наименование = Клиент.Наименование;  // Ещё раз загружает!

Хорошо (1 реквизит):
  ИНН = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Клиент, "ИНН");

Хорошо (несколько реквизитов от одного объекта):
  Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
      Клиент, 
      "ИНН, Наименование, КПП"
  );
  ИНН = Реквизиты.ИНН;
  Наименование = Реквизиты.Наименование;

Хорошо (1 реквизит от нескольких объектов):
  МассивКлиентов = Новый Массив;
  МассивКлиентов.Добавить(Клиент1);
  МассивКлиентов.Добавить(Клиент2);
  
  ИННы = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(МассивКлиентов, "ИНН");

Хорошо (несколько реквизитов от нескольких объектов):
  Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(
      МассивКлиентов,
      "ИНН, Наименование"
  );

Причина: Обращение через точку загружает весь объект из БД
```

### Кеширование

```yaml
Правило: При повторяющихся вычислениях в цикле используй кеширование

Плохо:
  Для Каждого Строка Из Таблица Цикл
      Коэффициент = ПолучитьКоэффициент(Строка.Дата);  // Повторные вызовы!
      Строка.Сумма = Строка.Сумма * Коэффициент;
  КонецЦикла;

Хорошо:
  КешКоэффициентов = Новый Соответствие;
  
  Для Каждого Строка Из Таблица Цикл
      Коэффициент = КешКоэффициентов[Строка.Дата];
      
      Если Коэффициент = Неопределено Тогда
          Коэффициент = ПолучитьКоэффициент(Строка.Дата);
          КешКоэффициентов.Вставить(Строка.Дата, Коэффициент);
      КонецЕсли;
      
      Строка.Сумма = Строка.Сумма * Коэффициент;
  КонецЦикла;

Причина: Избегаем повторных вычислений
```

---

## КЛИЕНТ-СЕРВЕР

### Директивы компиляции

```yaml
Правило: В модулях форм предпочитай &НаСервереБезКонтекста вместо &НаСервере

Плохо:
  &НаСервере
  Функция ПолучитьДанные()
      // Имеет доступ к реквизитам формы (контекст)
      // Сериализация контекста = overhead
  КонецФункции

Хорошо:
  &НаСервереБезКонтекста
  Функция ПолучитьДанные(Параметр1, Параметр2)
      // Не имеет доступа к реквизитам формы
      // Нет сериализации контекста
      // Быстрее
  КонецФункции

Исключение: Используй &НаСервере когда действительно нужен доступ к реквизитам формы
```

### Минимизация переходов

```yaml
Правило: Минимизируй переходы клиент-сервер

Плохо:
  &НаКлиенте
  Процедура ОбработатьДанные()
      Для Каждого Строка Из Таблица Цикл
          Строка.Сумма = ВычислитьСуммуНаСервере(Строка.Количество);  // N переходов!
      КонецЦикла;
  КонецПроцедуры

Хорошо:
  &НаКлиенте
  Процедура ОбработатьДанные()
      Таблица = ВычислитьСуммыНаСервере(Таблица);  // 1 переход
  КонецПроцедуры
  
  &НаСервереБезКонтекста
  Функция ВычислитьСуммыНаСервере(Таблица)
      Для Каждого Строка Из Таблица Цикл
          Строка.Сумма = ВычислитьСумму(Строка.Количество);
      КонецЦикла;
      Возврат Таблица;
  КонецФункции

Причина: Каждый переход клиент-сервер = сериализация + сеть
```

### Асинхронные методы

```yaml
Правило: Вместо ОписаниеОповещения используй Асинх-методы где возможно

Старый подход (ОписаниеОповещения):
  Оповещение = Новый ОписаниеОповещения("ПослеВопроса", ЭтотОбъект);
  ПоказатьВопрос(Оповещение, "Продолжить?", РежимДиалогаВопрос.ДаНет);
  
  Процедура ПослеВопроса(Результат, ДополнительныеПараметры) Экспорт
      Если Результат = КодВозвратаДиалога.Да Тогда
          // ...
      КонецЕсли;
  КонецПроцедуры

Новый подход (Асинх):
  Асинх Процедура СпроситьПользователя()
      Результат = Ждать ПоказатьВопросАсинх("Продолжить?", РежимДиалогаВопрос.ДаНет);
      
      Если Результат = КодВозвратаДиалога.Да Тогда
          // ...
      КонецЕсли;
  КонецПроцедуры

Причина: Асинх-методы проще читать и отлаживать (линейный код)
```

---

## СООБЩЕНИЯ И ОШИБКИ

### Вывод сообщений

```yaml
Правило: Не используй Сообщить()

Плохо:
  Сообщить("Ошибка!");  // Не контролируется, не локализуется

Хорошо (на сервере):
  ОбщегоНазначения.СообщитьПользователю(
      "Ошибка при обработке данных",
      ,
      "Объект.Реквизит",
      ,
      Отказ
  );

Хорошо (на клиенте):
  ОбщегоНазначенияКлиент.СообщитьПользователю(
      "Ошибка при обработке данных"
  );

Причина: БСП-методы поддерживают:
  - Привязку к полю формы
  - Локализацию
  - Логирование
  - Отмену действия (Отказ)
```

### Обработка исключений

```yaml
Правило: Не глотай исключения молча

Плохо:
  Попытка
      // Опасная операция
  Исключение
      // Молчим
  КонецПопытки;

Плохо:
  Попытка
      // Опасная операция
  Исключение
      Сообщить("Ошибка");  // Недостаточно информации
  КонецПопытки;

Хорошо:
  Попытка
      // Опасная операция
  Исключение
      ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
      
      ЗаписьЖурналаРегистрации(
          "Модуль.Функция",
          УровеньЖурналаРегистрации.Ошибка,
          ,
          ,
          ТекстОшибки
      );
      
      ВызватьИсключение;  // Пробрасываем дальше, если нужно
  КонецПопытки;

Правило: Обрабатывай только ожидаемые исключения
  - Если знаешь, что может произойти - обработай
  - Если не знаешь - не глотай, пусть всплывёт
```

---

## ДАТЫ И ВРЕМЯ

### Текущая дата

```yaml
Правило: Для текущей даты на сервере используй ТекущаяДатаСеанса()

Плохо:
  ТекущаяДата = ТекущаяДата();  // Дата сервера (UTC или локальная)

Хорошо:
  ТекущаяДата = ТекущаяДатаСеанса();  // Дата сеанса пользователя

Причина: 
  - ТекущаяДата() зависит от часового пояса сервера
  - ТекущаяДатаСеанса() учитывает часовой пояс пользователя
  - Важно для многопользовательских систем
```

---

## КОНКУРЕНТНОСТЬ

### Блокировки

```yaml
Правило: Проверяй код на конкурентность и необходимость блокировок

Когда нужны блокировки:
  - Изменение данных (запись объектов)
  - Чтение с последующей записью
  - Работа с последовательностями/автонумерацией
  - Критические секции

Типы блокировок:
  1. Управляемые (рекомендуется):
     Блокировка = Новый БлокировкаДанных;
     ЭлементБлокировки = Блокировка.Добавить("Справочник.Клиенты");
     ЭлементБлокировки.УстановитьЗначение("Ссылка", СсылкаКлиента);
     Блокировка.Заблокировать();
     
     // Работа с данными
     
     Блокировка.Разблокировать();
  
  2. Неуправляемые (устаревшие):
     ЗаблокироватьДанныеДляРедактирования(СсылкаКлиента);
     // Работа с данными
     РазблокироватьДанные(СсылкаКлиента);

Учитывай внешние транзакции:
  - Обработчики событий объектов (ПередЗаписью, ПриЗаписи)
  - Выполняются в транзакции записи объекта
  - Блокировки не нужны (уже заблокировано)
```

---

## ФОРМАТИРОВАНИЕ

### Ограничение строки

```yaml
Правило: Ограничение строки — 120 символов

Если строка длиннее:
  - Перенеси на новую строку
  - Выровняй отступы
  - Сохрани читаемость

Плохо:
  Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(МассивОбъектов, "Наименование, ИНН, КПП, ЮридическийАдрес, ФактическийАдрес");

Хорошо:
  Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(
      МассивОбъектов, 
      "Наименование, ИНН, КПП, ЮридическийАдрес, ФактическийАдрес"
  );

Или:
  РеквизитыДляПолучения = "Наименование, ИНН, КПП, "
      + "ЮридическийАдрес, ФактическийАдрес";
  
  Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(
      МассивОбъектов, 
      РеквизитыДляПолучения
  );
```

### Тернарный оператор

```yaml
Правило: Не используй тернарный оператор ?()

Плохо:
  Результат = ?(Условие, Значение1, Значение2);

Хорошо:
  Если Условие Тогда
      Результат = Значение1;
  Иначе
      Результат = Значение2;
  КонецЕсли;

Причина: 
  - Тернарный оператор менее читаем
  - Сложнее отлаживать
  - Не соответствует стилю 1С
```

---

## САМОКОНТРОЛЬ

### Ревью после редактирования

```yaml
Правило: После редактирования кода выполняй ревью

Проверяй:
  1. Стиль:
     - Соответствие стандартам
     - Именование
     - Форматирование
     - Комментарии
  
  2. Читаемость:
     - Понятен ли код?
     - Можно ли упростить?
     - Нет ли дублирования?
  
  3. Корректность:
     - Логика верна?
     - Обработаны ошибки?
     - Учтены граничные случаи?
  
  4. Безопасность:
     - Нет SQL injection?
     - Проверены права доступа?
     - Нет hardcoded секретов?
  
  5. Конкурентность:
     - Нужны ли блокировки?
     - Учтены гонки?
     - Нет deadlock'ов?

Инструменты:
  - BSL LSP Bridge: bsl_lsp_diagnostics(file_path)
  - Syntax checker: user-1c-syntax-checker-syntaxcheck(code)
  - Code checker: user-1c-code-checker-check_1c_code(code, "logic")
  - onec-code-reviewer: Полное ревью
```

---

## ИНТЕГРАЦИЯ С ИНСТРУМЕНТАМИ

### BSL LSP Bridge

```yaml
Используй для:
  - Диагностика кода (ошибки, предупреждения)
  - Форматирование
  - Навигация по коду
  - Автодополнение

Команды:
  bsl_lsp_diagnostics(file_path): Получить все проблемы
  bsl_lsp_format(file_path): Форматировать код
  bsl_lsp_symbols(file_path): Получить список функций
```

### MCP Серверы

```yaml
Справка по платформе:
  user-1c-help-docsearch("метод или функция")

БСП (Библиотека стандартных подсистем):
  user-1c-ssl-ssl_search("функциональность")

Шаблоны кода:
  user-1c-templates-templatesearch("описание задачи")

Проверка синтаксиса:
  user-1c-syntax-checker-syntaxcheck(code)

Проверка логики:
  user-1c-code-checker-check_1c_code(code, "logic")

Метаданные:
  user-kaf-codemetadata-metadatasearch("Справочники.Клиенты")
  user-kaf-graph-search_metadata("Справочник Клиенты")

Код:
  user-kaf-codemetadata-codesearch("функция или паттерн")
```

---

## КРИТИЧЕСКИЕ ПРАВИЛА

**Эти правила ОБЯЗАТЕЛЬНЫ и не могут быть нарушены:**

1. ✅ **Проверяй метаданные** перед написанием запросов
2. ✅ **Не используй запросы в цикле** (N+1 проблема)
3. ✅ **Не получай реквизиты через точку** (используй БСП)
4. ✅ **Логируй исключения** (не глотай молча)
5. ✅ **Используй ТекущаяДатаСеанса()** (не ТекущаяДата())
6. ✅ **Проверяй конкурентность** (блокировки где нужно)
7. ✅ **Не используй Сообщить()** (используй БСП)
8. ✅ **Не используй имена из глобального контекста** (коллизии)
9. ✅ **Проводи самоконтроль** (ревью после написания)
10. ✅ **Используй инструменты** (BSL LSP, MCP, RLM)

---

## ПРИМЕРЫ

### Пример 1: Правильная структура модуля

```bsl
#Область ПрограммныйИнтерфейс

// Получает данные клиента
//
// Параметры:
//   Клиент - СправочникСсылка.Клиенты - ссылка на клиента
//
// Возвращаемое значение:
//   Структура - данные клиента с полями:
//     * Наименование - Строка - наименование клиента
//     * ИНН - Строка - ИНН клиента
//     * КПП - Строка - КПП клиента
//
Функция ПолучитьДанныеКлиента(Клиент) Экспорт
    
    Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
        Клиент,
        "Наименование, ИНН, КПП"
    );
    
    Возврат Реквизиты;
    
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьКешКлиентов()
    
    Если КешКлиентов = Неопределено Тогда
        КешКлиентов = Новый Соответствие;
    КонецЕсли;
    
    Возврат КешКлиентов;
    
КонецФункции

#КонецОбласти
```

### Пример 2: Оптимизированный запрос

```bsl
Функция ПолучитьДанныеКлиентов(МассивКлиентов) Экспорт
    
    Запрос = Новый Запрос;
    Запрос.Текст = 
    "ВЫБРАТЬ
    |    Клиенты.Ссылка КАК Клиент,
    |    Клиенты.Наименование КАК Наименование,
    |    Клиенты.ИНН КАК ИНН,
    |    Данные.Адрес КАК Адрес,
    |    Данные.Телефон КАК Телефон
    |ИЗ
    |    Справочник.Клиенты КАК Клиенты
    |    ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ДанныеКлиентов КАК Данные
    |    ПО Клиенты.Ссылка = Данные.Клиент
    |ГДЕ
    |    Клиенты.Ссылка В (&МассивКлиентов)";
    
    Запрос.УстановитьПараметр("МассивКлиентов", МассивКлиентов);
    
    РезультатЗапроса = Запрос.Выполнить();
    
    Возврат РезультатЗапроса.Выгрузить();
    
КонецФункции
```

### Пример 3: Правильная обработка ошибок

```bsl
Процедура ОбработатьДанные(Данные) Экспорт
    
    Попытка
        // Опасная операция
        ВыполнитьОбработку(Данные);
    Исключение
        ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
        
        ЗаписьЖурналаРегистрации(
            "ОбщийМодуль.ОбработатьДанные",
            УровеньЖурналаРегистрации.Ошибка,
            ,
            ,
            ТекстОшибки
        );
        
        ОбщегоНазначения.СообщитьПользователю(
            "Ошибка при обработке данных. Подробности в журнале регистрации."
        );
        
        ВызватьИсключение;
    КонецПопытки;
    
КонецПроцедуры
```

---

**Последнее обновление**: 2026-02-08  
**Версия**: 1.0  
**Источник**: AndreevED/1c-ai-feature-dev-workflow + улучшения
